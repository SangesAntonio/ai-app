<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualizzazione Terremoti 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: white; }
    #graficoContainer { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="graficoContainer"></div>
  <div style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;">
    <label for="sizeSlider">Grandezza sfere:</label>
    <input type="range" id="sizeSlider" min="0.1" max="5" step="0.1" value="1"><br>
    <span style="color:rgb(162, 165, 0)">Giallo: Solfatara</span><br>
    <span style="color:rgb(0, 165, 11)">Verde: Montenuovo</span>
  </div>
  <div>
  </div>
  <script type="module">
   
    
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';

    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { TextureLoader } from 'three';

    document.addEventListener("DOMContentLoaded", () => {
      // Creazione della scena con sfondo bianco
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xDDffff);
      

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff, 1);
      document.getElementById("graficoContainer").appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      
      const pyramidLat = 40.8269;
      const pyramidLon = 14.1405;
      const pyramidDepth = 0;
      
      // Convertiamo le coordinate in 3D
      const pyramidPos = latLonToXYZ(pyramidLat, pyramidLon, pyramidDepth);
      const pyramidSecondPos = latLonToXYZ(40.8352, 14.0877,0);
      
      controls.target.set(pyramidPos.z, pyramidPos.y, pyramidPos.x);

      // Creazione della griglia
      const gridSize = 25;
      const gridDivisions = 5;
      const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x000000, 0x000000);

      // Sposta la griglia al centro della piramide
      gridHelper.position.set(pyramidPos.z, pyramidPos.y, pyramidPos.x);

      scene.add(gridHelper);

      // Aggiunta della luce
      const light = new THREE.AmbientLight(0xffffff, 2);
      scene.add(light);

      // Funzione per caricare il modello 3D con texture
      function load3DModel(modelPath, texturePath, position, scale) {
        const loader = new GLTFLoader();
        const textureLoader = new TextureLoader();

        loader.load(modelPath, (gltf) => {
          const model = gltf.scene;
          console.log("Modello caricato:", model);

          // Carica la texture
          const textureLoader = new THREE.TextureLoader();
const texture = textureLoader.load(texturePath, () => {
  console.log("Texture caricata con successo");

  // Imposta la ripetizione della texture
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(4, 4); // Modifica questi valori per adattare la texture
});

        // Applica la texture a tutte le mesh
        model.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshStandardMaterial({
              map: texture,
              side: THREE.DoubleSide,
            });
          }
        });


          // Forza una posizione visibile
          model.traverse((child) => {
  if (child.isMesh) {
    child.rotation.x = Math.PI; // Ruota ogni mesh individualmente
  }
});

          model.scale.set(scale, scale, scale);
          model.position.set(position.x, position.y, position.z);
          scene.add(model);
        }, undefined, (error) => {
          console.error("Errore nel caricamento del modello 3D:", error);
        });
      }

      // Percorsi dei file (assicurati che siano corretti)
      const modelPath = '/3dmodels/scene.gltf';
      const texturePath = '/3dmodels/textures/TerrainNodeMaterial_baseColor.jpeg';

      // Carichiamo il modello nella posizione della piramide
     // load3DModel(modelPath, texturePath, pyramidPos, -0.1);

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();


      // Impostiamo i parametri per la linea di profondità
      const maxDepth = 8;      // profondità massima in km
      const depthScale = 2;    // 1 km corrisponde a 2 unità lungo l'asse y

      // Creazione della linea verticale per la profondità (da y=0 a y = -maxDepth*depthScale)
      const depthLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, -maxDepth * depthScale, 0)
      ]);
      const depthLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
      const depthLine = new THREE.Line(depthLineGeometry, depthLineMaterial);
      scene.add(depthLine);
      depthLine.position.set(pyramidPos.z, pyramidPos.y, pyramidPos.x);

      // Funzione per aggiungere un tick mark orizzontale
      // Carica il font prima di creare i tick mark
const loaderTre = new FontLoader();
loaderTre.load('fonts/helvetiker_regular.typeface.json', (font) => {

  function addTickMark(y, index, tickLength = 2) {
    const halfTick = tickLength / 2;

    // Creazione della linea orizzontale
    const tickGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-halfTick, y, 0),
      new THREE.Vector3(halfTick, y, 0)
    ]);
    const tickMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
    const tick = new THREE.Line(tickGeometry, tickMaterial);
    scene.add(tick);
    tick.position.set(pyramidPos.z, pyramidPos.y, pyramidPos.x);

    // Non mostrare il numero sulla prima linea (superficie)
    if (index > 1) {
      // Creazione del numero accanto alla linea
      const textGeometry = new TextGeometry((index - 1).toString(), {
        font: font,
        size: 0.8,      // Dimensione del numero
        height: 0.1,
        depth:0.1  // Profondità minima per il testo 3D
      });
      const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);

      // Posizioniamo il numero accanto al tick mark
      //textMesh.position.set(halfTick + 1, y, 0);
      //scene.add(textMesh);
      //textMesh.position.set(halfTick + 1, pyramidPos.y, pyramidPos.x);
    }
  }

  // Creiamo i tick mark numerati (partendo da 2 invece che 1)
  for (let i = 0; i <= maxDepth; i++) {
    const y = -i * depthScale;
    addTickMark(y, i + 1); // Il numero 1 viene ignorato e la numerazione parte da 2
  }
});
      // Impostazione del centro della mappa:
      // Consideriamo lat=40 e lon=10 come centro, che verranno mappati su (0,0,0)
     

      // Funzione per convertire latitudine, longitudine e profondità (in km) in coordinate 3D
      function latLonToXYZ(lat, lon, depth) {
        // Definisci un fattore di scala per rendere le coordinate proporzionali alla profondità
        const depthScale = 2;  // 1 km = 2 unità Three.js (aggiustabile)
        const latLonScale = 100; // Scala per lat/lon per renderli coerenti (regolabile)

        const centerLat = 40;
        const centerLon = 15;

        return {
          x: (lon - centerLon) * latLonScale,
          y: -depth * depthScale,  // Profondità proporzionale
          z: (lat - centerLat) * latLonScale
        };
      }


      function isValidCoordinate(lat, lon, depth) {
        return !isNaN(lat) && !isNaN(lon) && !isNaN(depth) &&
               lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
      }

      function getMagnitude(earthquake) {
        return earthquake.magnitudos?.[0]?.value || 1;
      }
      // Carica il font (assicurati di avere il file font corretto nella cartella indicata)
      const loader = new FontLoader();
      loader.load('fonts/helvetiker_regular.typeface.json', (font) => {
      const textGeometry = new TextGeometry('Terremoti Campi flegrei', {
        font: font,
        size: 6,          // dimensione complessiva ridotta
        height: 5,      // profondità ridotta (ulteriore riduzione del 90% rispetto a 0.05 ad esempio)
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.001,
        bevelSize: 0.001,
        bevelOffset: 0,
        bevelSegments: 3,
        depth:0.2
      });
      const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);

      // Se serve, applica un'ulteriore scala per ridurre ulteriormente la dimensione
      textMesh.scale.set(0.5, 0.5, 0.5);

      // Ruota la scritta in modo che l'estrusione segua l'asse Y (orientata verso l'alto)
      textMesh.rotation.x = - Math.PI / 2;

      // Posiziona la scritta dove desideri, ad esempio vicino al bordo della griglia
      textMesh.position.set(-20, 0, -15);
      scene.add(textMesh);
      textMesh.position.set(pyramidPos.z-25, pyramidPos.y, pyramidPos.x+18);
      
    });

      function addPyramid(lat, lon, depth, color) {
          // Converti le coordinate geografiche in coordinate 3D
          const { x, y, z } = latLonToXYZ(lat, lon, depth);

          // Geometria della piramide (Tetraedro)
          const pyramidGeometry = new THREE.ConeGeometry(0.1, 0.4, 4); // Base 2, altezza 4, 4 lati
          const pyramidMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(color), wireframe: false });
          const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);

          // Posizioniamo la piramide
          pyramid.position.set(z, y, x);

          // Ruotiamo la piramide per allinearla meglio
          pyramid.rotation.y = Math.PI / 4; // Rotazione di 45° per farla sembrare più bilanciata

          // Aggiungiamo la piramide alla scena
          scene.add(pyramid);
        
      }

      // Aggiungi una piramide con un colore specifico
    
      addPyramid(40.8269, 14.1405, 0,0xEEff00); // giallo solfatara
      addPyramid(40.8352, 14.0877, 0,0x00ff00); // verde montenuovo
      let spheres = [];
      // Caricamento dei dati dei terremoti
      fetch('events25.json')
        .then(response => response.json())
        .then(data => {
          if (!Array.isArray(data)) {
            console.error("Errore: Il JSON non è un array.");
            return;
          }

          data.forEach(eq => {
            const { latitude, longitude, depth } = eq.location;
            if (!isValidCoordinate(latitude, longitude, depth)) return;

            const { x, y, z } = latLonToXYZ(latitude, longitude, depth);
            if (isNaN(x) || isNaN(y) || isNaN(z)) return;

            const magnitude = getMagnitude(eq);
            if (magnitude <= 0) return;

            // Calcola il colore: di base giallo che diventa più rosso con l'aumentare della magnitudo
            let factor = (magnitude - 1) / (5 - 1);
            factor = Math.max(0, Math.min(1, factor));
            const yellow = new THREE.Color(0x6397d0);
            const red = new THREE.Color(0xff0000);
            const color = yellow.clone().lerp(red, factor);
            

            const geometry = new THREE.SphereGeometry(magnitude * 0.01, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(z, y, x);
            //console.log(x,y,z)
            scene.add(sphere);
            spheres.push(sphere); // Salviamo la sfera nell'array
            
          });
        })
        
        .catch(error => console.error("Errore nel caricamento del JSON:", error));
        document.getElementById("sizeSlider").addEventListener("input", (event) => {
          const scaleFactor = parseFloat(event.target.value);
          
          spheres.forEach(sphere => {
            sphere.scale.set(scaleFactor, scaleFactor, scaleFactor);
          });
        });

      camera.position.set(pyramidPos.z,3, pyramidPos.x);
      camera.lookAt(pyramidPos.z, pyramidPos.y, pyramidPos.x);
      console.log(pyramidPos.z, pyramidPos.y, pyramidPos.x)

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    });

    
    
  </script>
</body>
</html>
